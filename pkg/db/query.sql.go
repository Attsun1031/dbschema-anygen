// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: query.sql

package db

import (
	"context"
)

const getColumnDefinitions = `-- name: GetColumnDefinitions :many
SELECT
    CAST(table_schema AS TEXT) AS table_schema,
    CAST(table_name AS TEXT) AS table_name,
    CAST(column_name AS TEXT) AS column_name,
    CAST(data_type AS TEXT) AS data_type,
    CASE (is_nullable)
        WHEN 'YES' THEN TRUE
        ELSE FALSE
    END AS is_nullable,
    CAST(ordinal_position AS INTEGER) AS ordinal_position
FROM information_schema.columns
WHERE table_schema = $1
ORDER BY table_schema, table_name, ordinal_position
`

type GetColumnDefinitionsRow struct {
	TableSchema     string `json:"table_schema"`
	TableName       string `json:"table_name"`
	ColumnName      string `json:"column_name"`
	DataType        string `json:"data_type"`
	IsNullable      bool   `json:"is_nullable"`
	OrdinalPosition int32  `json:"ordinal_position"`
}

func (q *Queries) GetColumnDefinitions(ctx context.Context, tableSchema interface{}) ([]GetColumnDefinitionsRow, error) {
	rows, err := q.db.Query(ctx, getColumnDefinitions, tableSchema)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetColumnDefinitionsRow
	for rows.Next() {
		var i GetColumnDefinitionsRow
		if err := rows.Scan(
			&i.TableSchema,
			&i.TableName,
			&i.ColumnName,
			&i.DataType,
			&i.IsNullable,
			&i.OrdinalPosition,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
